/**
 * generated by Xtext 2.34.0
 */
package org.xtext.example.pascal.generator;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.IntegerRange;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.xtext.example.pascal.pascal.abstraction_declaration;
import org.xtext.example.pascal.pascal.abstraction_heading;
import org.xtext.example.pascal.pascal.any_number;
import org.xtext.example.pascal.pascal.assignment_statement;
import org.xtext.example.pascal.pascal.block;
import org.xtext.example.pascal.pascal.case_limb;
import org.xtext.example.pascal.pascal.case_statement;
import org.xtext.example.pascal.pascal.compound_statement;
import org.xtext.example.pascal.pascal.conditional_statement;
import org.xtext.example.pascal.pascal.constant;
import org.xtext.example.pascal.pascal.expression;
import org.xtext.example.pascal.pascal.expression_list;
import org.xtext.example.pascal.pascal.factor;
import org.xtext.example.pascal.pascal.function_designator;
import org.xtext.example.pascal.pascal.if_statement;
import org.xtext.example.pascal.pascal.number;
import org.xtext.example.pascal.pascal.procedure_and_function_declaration_part;
import org.xtext.example.pascal.pascal.program;
import org.xtext.example.pascal.pascal.repetitive_statement;
import org.xtext.example.pascal.pascal.simple_expression;
import org.xtext.example.pascal.pascal.simple_statement;
import org.xtext.example.pascal.pascal.statement;
import org.xtext.example.pascal.pascal.statement_sequence;
import org.xtext.example.pascal.pascal.structured_statement;
import org.xtext.example.pascal.pascal.term;
import org.xtext.example.pascal.pascal.variable;
import org.xtext.example.pascal.validation.ElementType;
import org.xtext.example.pascal.validation.Function;
import org.xtext.example.pascal.validation.PascalValidator;
import org.xtext.example.pascal.validation.Procedure;
import org.xtext.example.pascal.validation.Type;
import org.xtext.example.pascal.validation.TypeInferer;
import org.xtext.example.pascal.validation.Variable;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class PascalGenerator extends AbstractGenerator {
  private HashMap<String, String> stringTable = new HashMap<String, String>();

  private int labelCount;

  private int conditionalLabelCount;

  private int caseLabelCount;

  private int caseGlobalLabelCount;

  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    Iterable<program> _filter = Iterables.<program>filter(IteratorExtensions.<EObject>toIterable(resource.getAllContents()), program.class);
    for (final program e : _filter) {
      {
        this.labelCount = 0;
        this.conditionalLabelCount = 0;
        this.caseLabelCount = 0;
        this.caseGlobalLabelCount = 0;
        this.stringTable.clear();
        String _name = e.getHeading().getName();
        String _plus = (_name + ".asm");
        fsa.generateFile(_plus, this.compile(e));
      }
    }
  }

  public void createStringTable(final program e) {
    Iterable<factor> _filter = Iterables.<factor>filter(IteratorExtensions.<EObject>toIterable(e.eAllContents()), factor.class);
    for (final factor s : _filter) {
      String _string = s.getString();
      boolean _notEquals = (!Objects.equal(_string, null));
      if (_notEquals) {
        boolean _containsKey = this.stringTable.containsKey(s.getString());
        boolean _not = (!_containsKey);
        if (_not) {
          String _string_1 = s.getString();
          int _size = this.stringTable.size();
          String _plus = ("__STRING_" + Integer.valueOf(_size));
          this.stringTable.put(_string_1, _plus);
        }
      }
    }
    Iterable<constant> _filter_1 = Iterables.<constant>filter(IteratorExtensions.<EObject>toIterable(e.eAllContents()), constant.class);
    for (final constant const_ : _filter_1) {
      String _string_2 = const_.getString();
      boolean _notEquals_1 = (!Objects.equal(_string_2, null));
      if (_notEquals_1) {
        boolean _containsKey_1 = this.stringTable.containsKey(const_.getString());
        boolean _not_1 = (!_containsKey_1);
        if (_not_1) {
          String _string_3 = const_.getString();
          int _size_1 = this.stringTable.size();
          String _plus_1 = ("__STRING_" + Integer.valueOf(_size_1));
          this.stringTable.put(_string_3, _plus_1);
        }
      }
    }
  }

  public String getName(final block b) {
    String lastName = b.toString().replaceAll("org.xtext.example.pascal.pascal.impl.blockImpl@", "");
    return lastName;
  }

  public Map<block, Set<Variable>> getVariables(final program e) {
    Map<String, Object> artefacts = PascalValidator.artefacts.get(e.getHeading().getName());
    Object _get = artefacts.get("variables");
    Map<block, Set<Variable>> map = ((Map<block, Set<Variable>>) _get);
    return map;
  }

  public Set<Variable> getVariables(final program e, final block b) {
    return this.getVariables(e).get(b);
  }

  public Map<block, Set<Procedure>> getProcedures(final program e) {
    Map<String, Object> artefacts = PascalValidator.artefacts.get(e.getHeading().getName());
    Object _get = artefacts.get("abstractions");
    Map<block, Set<Procedure>> map = ((Map<block, Set<Procedure>>) _get);
    return map;
  }

  public Set<Procedure> getProcedures(final program e, final block b) {
    return this.getProcedures(e).get(b);
  }

  public Object getValue(final Variable v) {
    Object _value = v.getValue();
    if ((_value instanceof String)) {
      String _replaceAll = v.getValue().toString().replaceAll("\'", "\"");
      String _plus = ("\'" + _replaceAll);
      return (_plus + "\'");
    } else {
      Object _value_1 = v.getValue();
      if ((_value_1 instanceof Boolean)) {
        boolean _equals = v.getValue().equals(Boolean.valueOf(true));
        if (_equals) {
          return Integer.valueOf(1);
        } else {
          return Integer.valueOf(0);
        }
      }
    }
    return v.getValue();
  }

  public Object getValue(final program e, final block b, final constant const_) {
    Set<Variable> variables = this.getVariables(e, b);
    Object value = PascalValidator.getValue(const_, variables);
    if ((value instanceof String)) {
      String _name = const_.getName();
      boolean _equals = Objects.equal(_name, null);
      if (_equals) {
        boolean _containsKey = this.stringTable.containsKey(value);
        if (_containsKey) {
          return this.stringTable.get(value);
        }
      } else {
        return const_.getName();
      }
    } else {
      if ((value instanceof Boolean)) {
        if ((((Boolean) value).booleanValue() == true)) {
          return Integer.valueOf(1);
        }
        return Integer.valueOf(0);
      }
    }
    return value;
  }

  public List<Variable> getArgumentTypes(final program e, final block b, final expression_list expList) {
    List<Variable> list = new ArrayList<Variable>();
    if ((Objects.equal(expList, null) || Objects.equal(expList.getExpressions(), null))) {
      return list;
    }
    int count = 0;
    EList<expression> _expressions = expList.getExpressions();
    for (final expression exp : _expressions) {
      int _plusPlus = count++;
      String _plus = ("arg_" + Integer.valueOf(_plusPlus));
      Type _type = this.getType(e, exp);
      Variable _variable = new Variable(_plus, _type, false, null, ElementType.PARAMETER);
      list.add(_variable);
    }
    return list;
  }

  public Type getType(final program e, final expression expr) {
    Map<String, Object> artefacts = PascalValidator.artefacts.get(e.getHeading().getName());
    Object _get = artefacts.get("calculatedTypes");
    Map<EObject, Type> map = ((Map<EObject, Type>) _get);
    return map.get(expr);
  }

  public CharSequence compile(final program e) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("; Program ");
    String _name = e.getHeading().getName();
    _builder.append(_name);
    _builder.newLineIfNotEmpty();
    _builder.append("global _main");
    _builder.newLine();
    _builder.newLine();
    _builder.append("extern _printf");
    _builder.newLine();
    _builder.append("extern _scanf ");
    _builder.newLine();
    _builder.newLine();
    _builder.append("; Loading constants and strings");
    _builder.newLine();
    _builder.append("section .data");
    _builder.newLine();
    _builder.append("\t");
    this.createStringTable(e);
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    CharSequence _compileStrings = this.compileStrings(e);
    _builder.append(_compileStrings, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    CharSequence _compileAllConstants = this.compileAllConstants(e, e.getBlock());
    _builder.append(_compileAllConstants, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("; Loading variables");
    _builder.newLine();
    _builder.append("section .bss");
    _builder.newLine();
    _builder.append("\t");
    CharSequence _compileAllVariables = this.compileAllVariables(e, e.getBlock());
    _builder.append(_compileAllVariables, "\t");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("; Code");
    _builder.newLine();
    _builder.append("section .text");
    _builder.newLine();
    CharSequence _printString = this.printString(e);
    _builder.append(_printString);
    _builder.newLineIfNotEmpty();
    CharSequence _printInteger = this.printInteger(e);
    _builder.append(_printInteger);
    _builder.newLineIfNotEmpty();
    CharSequence _printBoolean = this.printBoolean(e);
    _builder.append(_printBoolean);
    _builder.newLineIfNotEmpty();
    CharSequence _compileAllProcedures = this.compileAllProcedures(e, e.getBlock());
    _builder.append(_compileAllProcedures);
    _builder.newLineIfNotEmpty();
    _builder.append("_main:");
    _builder.newLine();
    CharSequence _compileSequence = this.compileSequence(e, e.getBlock(), e.getBlock().getStatement().getSequence());
    _builder.append(_compileSequence);
    _builder.append(" ");
    _builder.newLineIfNotEmpty();
    _builder.append("ret\t; Exit program");
    _builder.newLine();
    return _builder;
  }

  public CharSequence compileAllProcedures(final program e, final block b) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _compileProcedures = this.compileProcedures(e, b, this.getProcedures(e, b));
    _builder.append(_compileProcedures);
    _builder.newLineIfNotEmpty();
    {
      procedure_and_function_declaration_part _abstraction = b.getAbstraction();
      boolean _notEquals = (!Objects.equal(_abstraction, null));
      if (_notEquals) {
        {
          EList<abstraction_heading> _procedures = b.getAbstraction().getProcedures();
          for(final abstraction_heading p : _procedures) {
            {
              block _block = p.getBlock();
              boolean _notEquals_1 = (!Objects.equal(_block, null));
              if (_notEquals_1) {
                CharSequence _compileAllProcedures = this.compileAllProcedures(e, p.getBlock());
                _builder.append(_compileAllProcedures);
                _builder.newLineIfNotEmpty();
              }
            }
          }
        }
        {
          EList<abstraction_declaration> _functions = b.getAbstraction().getFunctions();
          for(final abstraction_declaration p_1 : _functions) {
            {
              block _block_1 = p_1.getBlock();
              boolean _notEquals_2 = (!Objects.equal(_block_1, null));
              if (_notEquals_2) {
                CharSequence _compileAllProcedures_1 = this.compileAllProcedures(e, p_1.getBlock());
                _builder.append(_compileAllProcedures_1);
                _builder.newLineIfNotEmpty();
              }
            }
          }
        }
      }
    }
    return _builder;
  }

  public CharSequence compileAllVariables(final program e, final block b) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _compileVariables = this.compileVariables(e, b, this.getVariables(e, b));
    _builder.append(_compileVariables);
    _builder.newLineIfNotEmpty();
    {
      procedure_and_function_declaration_part _abstraction = b.getAbstraction();
      boolean _notEquals = (!Objects.equal(_abstraction, null));
      if (_notEquals) {
        {
          EList<abstraction_heading> _procedures = b.getAbstraction().getProcedures();
          for(final abstraction_heading p : _procedures) {
            {
              block _block = p.getBlock();
              boolean _notEquals_1 = (!Objects.equal(_block, null));
              if (_notEquals_1) {
                CharSequence _compileAllVariables = this.compileAllVariables(e, p.getBlock());
                _builder.append(_compileAllVariables);
                _builder.newLineIfNotEmpty();
              }
            }
          }
        }
        {
          EList<abstraction_declaration> _functions = b.getAbstraction().getFunctions();
          for(final abstraction_declaration p_1 : _functions) {
            {
              block _block_1 = p_1.getBlock();
              boolean _notEquals_2 = (!Objects.equal(_block_1, null));
              if (_notEquals_2) {
                CharSequence _compileAllVariables_1 = this.compileAllVariables(e, p_1.getBlock());
                _builder.append(_compileAllVariables_1);
                _builder.newLineIfNotEmpty();
              }
            }
          }
        }
      }
    }
    return _builder;
  }

  public CharSequence compileAllConstants(final program e, final block b) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _compileConstants = this.compileConstants(e, b, this.getVariables(e, b));
    _builder.append(_compileConstants);
    _builder.newLineIfNotEmpty();
    {
      procedure_and_function_declaration_part _abstraction = b.getAbstraction();
      boolean _notEquals = (!Objects.equal(_abstraction, null));
      if (_notEquals) {
        {
          EList<abstraction_heading> _procedures = b.getAbstraction().getProcedures();
          for(final abstraction_heading p : _procedures) {
            {
              block _block = p.getBlock();
              boolean _notEquals_1 = (!Objects.equal(_block, null));
              if (_notEquals_1) {
                CharSequence _compileAllConstants = this.compileAllConstants(e, p.getBlock());
                _builder.append(_compileAllConstants);
                _builder.newLineIfNotEmpty();
              }
            }
          }
        }
        {
          EList<abstraction_declaration> _functions = b.getAbstraction().getFunctions();
          for(final abstraction_declaration p_1 : _functions) {
            {
              block _block_1 = p_1.getBlock();
              boolean _notEquals_2 = (!Objects.equal(_block_1, null));
              if (_notEquals_2) {
                CharSequence _compileAllConstants_1 = this.compileAllConstants(e, p_1.getBlock());
                _builder.append(_compileAllConstants_1);
                _builder.newLineIfNotEmpty();
              }
            }
          }
        }
      }
    }
    return _builder;
  }

  public CharSequence printString(final program e) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("; Print string");
    _builder.newLine();
    _builder.append("_print_string:");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("push eax");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("push ebx ");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("sub esp, ebx");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("mov [esp], dword eax");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("call _printf");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("add esp, ebx");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("pop eax ");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("pop ebx");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("ret ;return");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    return _builder;
  }

  public CharSequence printInteger(final program e) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("; Print integer");
    _builder.newLine();
    _builder.append("_print_integer:");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("push eax");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("sub esp, 4");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("mov [esp], eax");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("sub esp, 4");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("lea eax, [__PRINTF_I]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("mov [esp], eax");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("call _printf");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("add esp, 4");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("add esp, 4");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("pop eax");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("ret ;return ");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    return _builder;
  }

  public CharSequence printBoolean(final program e) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("; Print boolean");
    _builder.newLine();
    _builder.append("_print_boolean:");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("jnz .print_boolean_true");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("push eax");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("push ebx ");
    _builder.newLine();
    _builder.append("\t");
    CharSequence _print = this.print(e, "__BOOLEAN_FALSE");
    _builder.append(_print, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("pop eax");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("pop ebx");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("ret ;return");
    _builder.newLine();
    _builder.append("\t");
    _builder.append(".print_boolean_true:");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("push eax");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("push ebx ");
    _builder.newLine();
    _builder.append("\t");
    CharSequence _print_1 = this.print(e, "__BOOLEAN_TRUE");
    _builder.append(_print_1, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("pop eax");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("pop ebx");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("ret ;return");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    return _builder;
  }

  public CharSequence compileConstant(final program e, final block b, final Variable v) {
    StringConcatenation _builder = new StringConcatenation();
    {
      if (((Objects.equal(v.getType(), ElementType.CONSTANT) && (!v.isInherited())) && 
        (!v.getVarType().getRealType().toLowerCase().equals("array of char")))) {
        String _name = v.getName();
        _builder.append(_name);
        _builder.append("_");
        String _name_1 = this.getName(b);
        _builder.append(_name_1);
        _builder.append(" equ ");
        Object _value = this.getValue(v);
        _builder.append(_value);
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }

  public CharSequence compileString(final program e, final String name, final String value) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append(value);
    _builder.append(" db \'");
    String _replaceAll = name.replaceAll("\'", "");
    _builder.append(_replaceAll);
    _builder.append("\', 0");
    _builder.newLineIfNotEmpty();
    _builder.append(value);
    _builder.append("_SIZE equ $-");
    _builder.append(value);
    _builder.newLineIfNotEmpty();
    return _builder;
  }

  public CharSequence compileVariable(final program e, final block b, final Variable v) {
    StringConcatenation _builder = new StringConcatenation();
    {
      if ((((Objects.equal(v.getType(), ElementType.VARIABLE) || Objects.equal(v.getType(), ElementType.PARAMETER)) || 
        Objects.equal(v.getType(), ElementType.FUNCTION_RETURN)) && (!v.isInherited()))) {
        {
          boolean _equals = v.getVarType().getRealType().toLowerCase().equals("array of char");
          boolean _not = (!_equals);
          if (_not) {
            {
              ElementType _type = v.getType();
              boolean _equals_1 = Objects.equal(_type, ElementType.FUNCTION_RETURN);
              if (_equals_1) {
                String _extendedName = v.getExtendedName();
                _builder.append(_extendedName);
                _builder.append("_");
                String _name = this.getName(b);
                _builder.append(_name);
                _builder.append(" RESB 4");
                _builder.newLineIfNotEmpty();
              } else {
                String _name_1 = v.getName();
                _builder.append(_name_1);
                _builder.append("_");
                String _name_2 = this.getName(b);
                _builder.append(_name_2);
                _builder.append(" RESB 4");
                _builder.newLineIfNotEmpty();
              }
            }
          }
        }
      }
    }
    return _builder;
  }

  public CharSequence compileStrings(final program e) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("__NEW_LINE db 10, 0");
    _builder.newLine();
    _builder.append("__NEW_LINE_SIZE equ $-__NEW_LINE");
    _builder.newLine();
    _builder.append("__PRINTF_S db \'%s\', 0");
    _builder.newLine();
    _builder.append("__PRINTF_I db \'%d\', 0");
    _builder.newLine();
    _builder.append("__PRINTF_F db \'%f\', 0");
    _builder.newLine();
    _builder.append("__BOOLEAN_TRUE db \'true\', 0");
    _builder.newLine();
    _builder.append("__BOOLEAN_TRUE_SIZE equ $-__BOOLEAN_TRUE");
    _builder.newLine();
    _builder.append("__BOOLEAN_FALSE db \'false\', 0");
    _builder.newLine();
    _builder.append("__BOOLEAN_FALSE_SIZE equ $-__BOOLEAN_FALSE");
    _builder.newLine();
    {
      Set<String> _keySet = this.stringTable.keySet();
      for(final String s : _keySet) {
        CharSequence _compileString = this.compileString(e, s, this.stringTable.get(s));
        _builder.append(_compileString);
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }

  public CharSequence compileConstants(final program e, final block b, final Set<Variable> variables) {
    StringConcatenation _builder = new StringConcatenation();
    {
      for(final Variable variable : variables) {
        CharSequence _compileConstant = this.compileConstant(e, b, variable);
        _builder.append(_compileConstant);
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }

  public CharSequence compileVariables(final program e, final block b, final Set<Variable> variables) {
    StringConcatenation _builder = new StringConcatenation();
    {
      for(final Variable variable : variables) {
        CharSequence _compileVariable = this.compileVariable(e, b, variable);
        _builder.append(_compileVariable);
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }

  public CharSequence compileProcedures(final program e, final block b, final Set<Procedure> procedures) {
    StringConcatenation _builder = new StringConcatenation();
    {
      for(final Procedure procedure : procedures) {
        CharSequence _compileProcedure = this.compileProcedure(e, b, procedure);
        _builder.append(_compileProcedure);
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }

  public CharSequence compileProcedure(final program e, final block b, final Procedure procedure) {
    StringConcatenation _builder = new StringConcatenation();
    {
      if (((!procedure.isForward()) && (!procedure.isInherited()))) {
        _builder.append("; Procedure ");
        String _name = procedure.getName();
        _builder.append(_name);
        List<Variable> _parameters = procedure.getParameters();
        _builder.append(_parameters);
        _builder.newLineIfNotEmpty();
        _builder.append("_");
        String _extendedName = procedure.getExtendedName();
        _builder.append(_extendedName);
        _builder.append("_");
        String _name_1 = this.getName(b);
        _builder.append(_name_1);
        _builder.append(":");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        CharSequence _compileSequence = this.compileSequence(e, procedure.getDeclaration().getBlock(), procedure.getDeclaration().getBlock().getStatement().getSequence());
        _builder.append(_compileSequence, "\t");
        _builder.newLineIfNotEmpty();
        {
          if ((procedure instanceof Function)) {
            _builder.append("\t");
            _builder.append("mov eax, [");
            String _extendedName_1 = ((Function)procedure).getExtendedName();
            _builder.append(_extendedName_1, "\t");
            _builder.append("_");
            String _name_2 = this.getName(((Function)procedure).getDeclaration().getBlock());
            _builder.append(_name_2, "\t");
            _builder.append("]");
            _builder.newLineIfNotEmpty();
          }
        }
        _builder.append("\t");
        _builder.append("ret ;return");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
      }
    }
    return _builder;
  }

  public CharSequence computeFunction(final program e, final block b, final function_designator function) {
    StringConcatenation _builder = new StringConcatenation();
    String name = function.getName();
    _builder.newLineIfNotEmpty();
    List<Variable> arguments = this.getArgumentTypes(e, b, function.getExpressions());
    _builder.newLineIfNotEmpty();
    Procedure functionToSearch = new Procedure(name, arguments);
    _builder.newLineIfNotEmpty();
    Procedure functionFound = PascalValidator.searchWithTypeCoersion(this.getProcedures(e, b), functionToSearch);
    _builder.newLineIfNotEmpty();
    {
      List<Variable> _parameters = functionFound.getParameters();
      for(final Variable arg : _parameters) {
        _builder.append("mov edx, ");
        String _name = arg.getName();
        _builder.append(_name);
        _builder.append("_");
        String _name_1 = this.getName(functionFound.getDeclaration().getBlock());
        _builder.append(_name_1);
        _builder.newLineIfNotEmpty();
        _builder.append("push edx");
        _builder.newLine();
      }
    }
    {
      if (((!Objects.equal(function.getExpressions(), null)) && (!Objects.equal(function.getExpressions().getExpressions(), null)))) {
        EList<expression> exps = function.getExpressions().getExpressions();
        _builder.newLineIfNotEmpty();
        {
          int _size = exps.size();
          int _minus = (_size - 1);
          IntegerRange _upTo = new IntegerRange(0, _minus);
          for(final Integer i : _upTo) {
            CharSequence _computeExpression = this.computeExpression(e, b, exps.get((i).intValue()));
            _builder.append(_computeExpression);
            _builder.newLineIfNotEmpty();
            _builder.append("mov [");
            String _name_2 = functionFound.getParameters().get((i).intValue()).getName();
            _builder.append(_name_2);
            _builder.append("_");
            String _name_3 = this.getName(functionFound.getDeclaration().getBlock());
            _builder.append(_name_3);
            _builder.append("], eax");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    _builder.append("call _");
    String _extendedName = functionFound.getExtendedName();
    _builder.append(_extendedName);
    _builder.append("_");
    String _name_4 = this.getName(functionFound.getContainingBlock());
    _builder.append(_name_4);
    _builder.newLineIfNotEmpty();
    {
      List<Variable> _parameters_1 = functionFound.getParameters();
      for(final Variable arg_1 : _parameters_1) {
        _builder.append("pop edx");
        _builder.newLine();
        _builder.append("mov [");
        String _name_5 = arg_1.getName();
        _builder.append(_name_5);
        _builder.append("_");
        String _name_6 = this.getName(functionFound.getDeclaration().getBlock());
        _builder.append(_name_6);
        _builder.append("], edx");
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }

  public CharSequence computeFactor(final program e, final block b, final factor f) {
    StringConcatenation _builder = new StringConcatenation();
    {
      String _string = f.getString();
      boolean _notEquals = (!Objects.equal(_string, null));
      if (_notEquals) {
        _builder.append("lea eax, [");
        String _get = this.stringTable.get(f.getString());
        _builder.append(_get);
        _builder.append("]");
        _builder.newLineIfNotEmpty();
        _builder.append("mov ebx, ");
        String _get_1 = this.stringTable.get(f.getString());
        _builder.append(_get_1);
        _builder.append("_SIZE");
        _builder.newLineIfNotEmpty();
      } else {
        number _number = f.getNumber();
        boolean _notEquals_1 = (!Objects.equal(_number, null));
        if (_notEquals_1) {
          {
            String _integer = f.getNumber().getNumber().getInteger();
            boolean _notEquals_2 = (!Objects.equal(_integer, null));
            if (_notEquals_2) {
              _builder.append("mov eax, ");
              String _integer_1 = f.getNumber().getNumber().getInteger();
              _builder.append(_integer_1);
              _builder.newLineIfNotEmpty();
            } else {
            }
          }
        } else {
          String _boolean = f.getBoolean();
          boolean _notEquals_3 = (!Objects.equal(_boolean, null));
          if (_notEquals_3) {
            {
              boolean _equals = f.getBoolean().toLowerCase().equals("true");
              if (_equals) {
                _builder.append("mov eax, 1");
                _builder.newLine();
              } else {
                _builder.append("mov eax, 0");
                _builder.newLine();
              }
            }
          } else {
            variable _variable = f.getVariable();
            boolean _notEquals_4 = (!Objects.equal(_variable, null));
            if (_notEquals_4) {
              Set<Variable> _variables = this.getVariables(e, b);
              String _name = f.getVariable().getName();
              Variable _variable_1 = new Variable(_name);
              Variable variableFound = PascalValidator.<Variable>search(_variables, _variable_1);
              _builder.newLineIfNotEmpty();
              {
                ElementType _type = variableFound.getType();
                boolean _equals_1 = Objects.equal(_type, ElementType.CONSTANT);
                if (_equals_1) {
                  {
                    boolean _equals_2 = variableFound.getVarType().getRealType().toLowerCase().equals("array of char");
                    if (_equals_2) {
                      _builder.append("lea eax, [");
                      Object _value = variableFound.getValue();
                      String _get_2 = this.stringTable.get(((String) _value));
                      _builder.append(_get_2);
                      _builder.append("]");
                      _builder.newLineIfNotEmpty();
                      _builder.append("mov ebx, ");
                      Object _value_1 = variableFound.getValue();
                      String _get_3 = this.stringTable.get(((String) _value_1));
                      _builder.append(_get_3);
                      _builder.append("_SIZE");
                      _builder.newLineIfNotEmpty();
                    } else {
                      _builder.append("mov eax, ");
                      String _name_1 = this.getName(variableFound.getContainingBlock());
                      _builder.append(_name_1);
                      _builder.append("_");
                      String _name_2 = variableFound.getName();
                      _builder.append(_name_2);
                      _builder.newLineIfNotEmpty();
                    }
                  }
                } else {
                  {
                    ElementType _type_1 = variableFound.getType();
                    boolean _equals_3 = Objects.equal(_type_1, ElementType.FUNCTION_RETURN);
                    if (_equals_3) {
                      _builder.append("mov eax, [");
                      String _extendedName = variableFound.getExtendedName();
                      _builder.append(_extendedName);
                      _builder.append("_");
                      String _name_3 = this.getName(variableFound.getContainingBlock());
                      _builder.append(_name_3);
                      _builder.append("]");
                      _builder.newLineIfNotEmpty();
                    } else {
                      _builder.append("mov eax, [");
                      String _name_4 = variableFound.getName();
                      _builder.append(_name_4);
                      _builder.append("_");
                      String _name_5 = this.getName(variableFound.getContainingBlock());
                      _builder.append(_name_5);
                      _builder.append("]");
                      _builder.newLineIfNotEmpty();
                    }
                  }
                }
              }
            } else {
              function_designator _function = f.getFunction();
              boolean _notEquals_5 = (!Objects.equal(_function, null));
              if (_notEquals_5) {
                CharSequence _computeFunction = this.computeFunction(e, b, f.getFunction());
                _builder.append(_computeFunction);
                _builder.newLineIfNotEmpty();
              } else {
                expression _expression = f.getExpression();
                boolean _notEquals_6 = (!Objects.equal(_expression, null));
                if (_notEquals_6) {
                  CharSequence _computeExpression = this.computeExpression(e, b, f.getExpression());
                  _builder.append(_computeExpression);
                  _builder.newLineIfNotEmpty();
                } else {
                  factor _not = f.getNot();
                  boolean _notEquals_7 = (!Objects.equal(_not, null));
                  if (_notEquals_7) {
                    CharSequence _computeFactor = this.computeFactor(e, b, f.getNot());
                    _builder.append(_computeFactor);
                    _builder.newLineIfNotEmpty();
                    _builder.append("xor eax, 1 ; Logical not");
                    _builder.newLine();
                  }
                }
              }
            }
          }
        }
      }
    }
    return _builder;
  }

  public CharSequence computeTerm(final program e, final block b, final term t) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("push ecx");
    _builder.newLine();
    CharSequence _computeFactor = this.computeFactor(e, b, t.getFactors().get(0));
    _builder.append(_computeFactor);
    _builder.newLineIfNotEmpty();
    {
      EList<String> _operators = t.getOperators();
      boolean _notEquals = (!Objects.equal(_operators, null));
      if (_notEquals) {
        int index = 1;
        _builder.newLineIfNotEmpty();
        {
          EList<String> _operators_1 = t.getOperators();
          for(final String operator : _operators_1) {
            _builder.append("mov ecx, eax");
            _builder.newLine();
            EList<factor> _factors = t.getFactors();
            int _plusPlus = index++;
            CharSequence _computeFactor_1 = this.computeFactor(e, b, _factors.get(_plusPlus));
            _builder.append(_computeFactor_1);
            _builder.newLineIfNotEmpty();
            {
              boolean _equals = operator.toLowerCase().equals("and");
              if (_equals) {
                _builder.append("and ecx, eax ; And");
                _builder.newLine();
              } else {
                boolean _equals_1 = operator.toLowerCase().equals("mod");
                if (_equals_1) {
                  _builder.append("mov edx, eax ; Module");
                  _builder.newLine();
                  _builder.append("mov eax, ecx");
                  _builder.newLine();
                  _builder.append("mov ecx, edx");
                  _builder.newLine();
                  _builder.append("cdq");
                  _builder.newLine();
                  _builder.append("idiv ecx");
                  _builder.newLine();
                  _builder.append("mov ecx, edx");
                  _builder.newLine();
                } else {
                  if ((operator.toLowerCase().equals("div") || operator.equals("/"))) {
                    _builder.append("mov edx, eax ; Divide");
                    _builder.newLine();
                    _builder.append("mov eax, ecx");
                    _builder.newLine();
                    _builder.append("mov ecx, edx");
                    _builder.newLine();
                    _builder.append("cdq");
                    _builder.newLine();
                    _builder.append("idiv ecx");
                    _builder.newLine();
                    _builder.append("mov ecx, eax");
                    _builder.newLine();
                  } else {
                    boolean _equals_2 = operator.equals("*");
                    if (_equals_2) {
                      _builder.append("mul ecx ; Multiply");
                      _builder.newLine();
                      _builder.append("mov ecx, eax");
                      _builder.newLine();
                    }
                  }
                }
              }
            }
            _builder.append("mov eax, ecx");
            _builder.newLine();
          }
        }
      }
    }
    _builder.append("pop ecx");
    _builder.newLine();
    return _builder;
  }

  public CharSequence computeSimpleExpression(final program e, final block b, final simple_expression exp) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("push ecx");
    _builder.newLine();
    EObject _get = exp.getTerms().get(0);
    CharSequence _computeTerm = this.computeTerm(e, b, ((term) _get));
    _builder.append(_computeTerm);
    _builder.newLineIfNotEmpty();
    {
      String _prefixOperator = exp.getPrefixOperator();
      boolean _notEquals = (!Objects.equal(_prefixOperator, null));
      if (_notEquals) {
        {
          boolean _equals = exp.getPrefixOperator().equals("-");
          if (_equals) {
            _builder.append("neg aex");
            _builder.newLine();
          }
        }
      }
    }
    {
      EList<String> _operators = exp.getOperators();
      boolean _notEquals_1 = (!Objects.equal(_operators, null));
      if (_notEquals_1) {
        int index = 1;
        _builder.newLineIfNotEmpty();
        {
          EList<String> _operators_1 = exp.getOperators();
          for(final String operator : _operators_1) {
            _builder.append("mov ecx, eax");
            _builder.newLine();
            {
              EObject _get_1 = exp.getTerms().get(index);
              if ((_get_1 instanceof term)) {
                EList<EObject> _terms = exp.getTerms();
                int _plusPlus = index++;
                EObject _get_2 = _terms.get(_plusPlus);
                CharSequence _computeTerm_1 = this.computeTerm(e, b, ((term) _get_2));
                _builder.append(_computeTerm_1);
                _builder.newLineIfNotEmpty();
              } else {
                _builder.append("mov eax, ");
                EList<EObject> _terms_1 = exp.getTerms();
                int _plusPlus_1 = index++;
                EObject _get_3 = _terms_1.get(_plusPlus_1);
                String _integer = ((any_number) _get_3).getInteger();
                _builder.append(_integer);
                _builder.newLineIfNotEmpty();
              }
            }
            {
              boolean _equals_1 = operator.equals("or");
              if (_equals_1) {
                _builder.append("or ecx, eax ; Logical or");
                _builder.newLine();
              } else {
                boolean _equals_2 = operator.equals("+");
                if (_equals_2) {
                  _builder.append("add ecx, eax ; Sum");
                  _builder.newLine();
                } else {
                  boolean _equals_3 = operator.equals("-");
                  if (_equals_3) {
                    _builder.append("sub ecx, eax ; Sub");
                    _builder.newLine();
                  }
                }
              }
            }
            _builder.append("mov eax, ecx");
            _builder.newLine();
          }
        }
      }
    }
    _builder.append("pop ecx");
    _builder.newLine();
    return _builder;
  }

  public CharSequence computeExpression(final program e, final block b, final expression exp) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("push ecx");
    _builder.newLine();
    CharSequence _computeSimpleExpression = this.computeSimpleExpression(e, b, exp.getExpressions().get(0));
    _builder.append(_computeSimpleExpression);
    _builder.newLineIfNotEmpty();
    {
      EList<String> _operators = exp.getOperators();
      boolean _notEquals = (!Objects.equal(_operators, null));
      if (_notEquals) {
        int index = 1;
        _builder.newLineIfNotEmpty();
        {
          EList<String> _operators_1 = exp.getOperators();
          for(final String operator : _operators_1) {
            _builder.append("mov ecx, eax");
            _builder.newLine();
            EList<simple_expression> _expressions = exp.getExpressions();
            int _plusPlus = index++;
            CharSequence _computeSimpleExpression_1 = this.computeSimpleExpression(e, b, _expressions.get(_plusPlus));
            _builder.append(_computeSimpleExpression_1);
            _builder.newLineIfNotEmpty();
            _builder.append("cmp ecx, eax");
            _builder.newLine();
            {
              boolean _equals = operator.equals("=");
              if (_equals) {
                _builder.append("je .set_to_true");
                _builder.append(this.labelCount);
                _builder.append(" ; Equal");
                _builder.newLineIfNotEmpty();
                _builder.append("jmp .set_to_false");
                _builder.append(this.labelCount);
                _builder.newLineIfNotEmpty();
              } else {
                boolean _equals_1 = operator.equals(">");
                if (_equals_1) {
                  _builder.append("jg .set_to_true");
                  _builder.append(this.labelCount);
                  _builder.append(" ; Greater");
                  _builder.newLineIfNotEmpty();
                  _builder.append("jmp .set_to_false");
                  _builder.append(this.labelCount);
                  _builder.newLineIfNotEmpty();
                } else {
                  boolean _equals_2 = operator.equals(">=");
                  if (_equals_2) {
                    _builder.append("jge .set_to_true");
                    _builder.append(this.labelCount);
                    _builder.append(" ; Greater or equal");
                    _builder.newLineIfNotEmpty();
                    _builder.append("jmp .set_to_false");
                    _builder.append(this.labelCount);
                    _builder.newLineIfNotEmpty();
                  } else {
                    boolean _equals_3 = operator.equals("<");
                    if (_equals_3) {
                      _builder.append("jl .set_to_true");
                      _builder.append(this.labelCount);
                      _builder.append(" ; Lesser");
                      _builder.newLineIfNotEmpty();
                      _builder.append("jmp .set_to_false");
                      _builder.append(this.labelCount);
                      _builder.newLineIfNotEmpty();
                    } else {
                      boolean _equals_4 = operator.equals("<=");
                      if (_equals_4) {
                        _builder.append("jle .set_to_true");
                        _builder.append(this.labelCount);
                        _builder.append(" ; Lesser of equal");
                        _builder.newLineIfNotEmpty();
                        _builder.append("jmp .set_to_false");
                        _builder.append(this.labelCount);
                        _builder.newLineIfNotEmpty();
                      } else {
                        boolean _equals_5 = operator.equals("<>");
                        if (_equals_5) {
                          _builder.append("jne .set_to_true");
                          _builder.append(this.labelCount);
                          _builder.append(" ; Different");
                          _builder.newLineIfNotEmpty();
                          _builder.append("jmp .set_to_false");
                          _builder.append(this.labelCount);
                          _builder.newLineIfNotEmpty();
                        }
                      }
                    }
                  }
                }
              }
            }
            _builder.append(".set_to_true");
            _builder.append(this.labelCount);
            _builder.append(":");
            _builder.newLineIfNotEmpty();
            _builder.append("\t");
            _builder.append("mov ecx, 1");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("jmp .out");
            _builder.append(this.labelCount, "\t");
            _builder.newLineIfNotEmpty();
            _builder.append(".set_to_false");
            _builder.append(this.labelCount);
            _builder.append(":");
            _builder.newLineIfNotEmpty();
            _builder.append("\t");
            _builder.append("mov ecx, 0");
            _builder.newLine();
            _builder.append(".out");
            int _plusPlus_1 = this.labelCount++;
            _builder.append(_plusPlus_1);
            _builder.append(":");
            _builder.newLineIfNotEmpty();
            _builder.append("\t");
            _builder.append("mov eax, ecx");
            _builder.newLine();
          }
        }
      }
    }
    _builder.append("pop ecx");
    _builder.newLine();
    return _builder;
  }

  public CharSequence print(final program e, final block b, final function_designator function) {
    StringConcatenation _builder = new StringConcatenation();
    {
      expression_list _expressions = function.getExpressions();
      boolean _notEquals = (!Objects.equal(_expressions, null));
      if (_notEquals) {
        CharSequence _computeExpression = this.computeExpression(e, b, function.getExpressions().getExpressions().get(0));
        _builder.append(_computeExpression);
        _builder.newLineIfNotEmpty();
        {
          int _typeWeight = TypeInferer.getTypeWeight(this.getType(e, function.getExpressions().getExpressions().get(0)));
          boolean _equals = (_typeWeight == 4);
          if (_equals) {
            _builder.append("call _print_float");
            _builder.newLine();
          } else {
            int _typeWeight_1 = TypeInferer.getTypeWeight(this.getType(e, function.getExpressions().getExpressions().get(0)));
            boolean _greaterEqualsThan = (_typeWeight_1 >= 0);
            if (_greaterEqualsThan) {
              _builder.append("call _print_integer");
              _builder.newLine();
            } else {
              boolean _equals_1 = this.getType(e, function.getExpressions().getExpressions().get(0)).getRealType().toLowerCase().equals("boolean");
              if (_equals_1) {
                _builder.append("and eax, 1 ; Setting zero flag");
                _builder.newLine();
                _builder.append("call _print_boolean");
                _builder.newLine();
              } else {
                _builder.append("call _print_string");
                _builder.newLine();
              }
            }
          }
        }
      }
    }
    return _builder;
  }

  public CharSequence print(final program e, final String s) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("lea eax, [");
    _builder.append(s);
    _builder.append("]");
    _builder.newLineIfNotEmpty();
    _builder.append("mov ebx, ");
    _builder.append(s);
    _builder.append("_SIZE");
    _builder.newLineIfNotEmpty();
    _builder.append("call _print_string");
    _builder.newLine();
    return _builder;
  }

  public CharSequence compileSequence(final program e, final block b, final statement_sequence sequence) {
    StringConcatenation _builder = new StringConcatenation();
    {
      EList<statement> _statements = sequence.getStatements();
      for(final statement stmt : _statements) {
        CharSequence _compileStatement = this.compileStatement(e, b, stmt);
        _builder.append(_compileStatement);
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }

  public CharSequence compileStatement(final program e, final block b, final statement s) {
    StringConcatenation _builder = new StringConcatenation();
    {
      simple_statement _simple = s.getSimple();
      boolean _notEquals = (!Objects.equal(_simple, null));
      if (_notEquals) {
        {
          assignment_statement _assignment = s.getSimple().getAssignment();
          boolean _notEquals_1 = (!Objects.equal(_assignment, null));
          if (_notEquals_1) {
            _builder.append("; Assigning ");
            String _name = s.getSimple().getAssignment().getVariable().getName();
            _builder.append(_name);
            _builder.newLineIfNotEmpty();
            CharSequence _computeExpression = this.computeExpression(e, b, s.getSimple().getAssignment().getExpression());
            _builder.append(_computeExpression);
            _builder.newLineIfNotEmpty();
            Set<Variable> _variables = this.getVariables(e, b);
            String _name_1 = s.getSimple().getAssignment().getVariable().getName();
            Variable _variable = new Variable(_name_1);
            Variable variableFound = PascalValidator.<Variable>search(_variables, _variable);
            _builder.newLineIfNotEmpty();
            {
              ElementType _type = variableFound.getType();
              boolean _equals = Objects.equal(_type, ElementType.FUNCTION_RETURN);
              if (_equals) {
                _builder.append("mov [");
                String _extendedName = variableFound.getExtendedName();
                _builder.append(_extendedName);
                _builder.append("_");
                String _name_2 = this.getName(variableFound.getContainingBlock());
                _builder.append(_name_2);
                _builder.append("], eax");
                _builder.newLineIfNotEmpty();
              } else {
                _builder.append("mov [");
                String _name_3 = variableFound.getName();
                _builder.append(_name_3);
                _builder.append("_");
                String _name_4 = this.getName(variableFound.getContainingBlock());
                _builder.append(_name_4);
                _builder.append("], eax");
                _builder.newLineIfNotEmpty();
              }
            }
          } else {
            String _function_noargs = s.getSimple().getFunction_noargs();
            boolean _notEquals_2 = (!Objects.equal(_function_noargs, null));
            if (_notEquals_2) {
              {
                boolean _equals_1 = s.getSimple().getFunction_noargs().equals("writeln");
                if (_equals_1) {
                  _builder.append("; Call writeln");
                  _builder.newLine();
                  CharSequence _print = this.print(e, "__NEW_LINE");
                  _builder.append(_print);
                  _builder.newLineIfNotEmpty();
                } else {
                  _builder.append("; Call ");
                  String _function_noargs_1 = s.getSimple().getFunction_noargs();
                  _builder.append(_function_noargs_1);
                  _builder.newLineIfNotEmpty();
                  Set<Procedure> _procedures = this.getProcedures(e, b);
                  String _function_noargs_2 = s.getSimple().getFunction_noargs();
                  ArrayList<Variable> _arrayList = new ArrayList<Variable>();
                  Procedure _procedure = new Procedure(_function_noargs_2, _arrayList);
                  Procedure functionFound = PascalValidator.<Procedure>search(_procedures, _procedure);
                  _builder.newLineIfNotEmpty();
                  _builder.append("call _");
                  String _extendedName_1 = functionFound.getExtendedName();
                  _builder.append(_extendedName_1);
                  _builder.append("_");
                  String _name_5 = this.getName(functionFound.getContainingBlock());
                  _builder.append(_name_5);
                  _builder.newLineIfNotEmpty();
                }
              }
            } else {
              function_designator _function = s.getSimple().getFunction();
              boolean _notEquals_3 = (!Objects.equal(_function, null));
              if (_notEquals_3) {
                {
                  boolean _equals_2 = s.getSimple().getFunction().getName().equals("write");
                  if (_equals_2) {
                    _builder.append("; Call write");
                    _builder.newLine();
                    CharSequence _print_1 = this.print(e, b, s.getSimple().getFunction());
                    _builder.append(_print_1);
                    _builder.newLineIfNotEmpty();
                  } else {
                    boolean _equals_3 = s.getSimple().getFunction().getName().equals("writeln");
                    if (_equals_3) {
                      _builder.append("; Call writeln");
                      _builder.newLine();
                      CharSequence _print_2 = this.print(e, b, s.getSimple().getFunction());
                      _builder.append(_print_2);
                      _builder.newLineIfNotEmpty();
                      CharSequence _print_3 = this.print(e, "__NEW_LINE");
                      _builder.append(_print_3);
                      _builder.newLineIfNotEmpty();
                    } else {
                      _builder.append("; Call ");
                      String _name_6 = s.getSimple().getFunction().getName();
                      _builder.append(_name_6);
                      _builder.newLineIfNotEmpty();
                      CharSequence _computeFunction = this.computeFunction(e, b, s.getSimple().getFunction());
                      _builder.append(_computeFunction);
                      _builder.newLineIfNotEmpty();
                    }
                  }
                }
              }
            }
          }
        }
      } else {
        structured_statement _structured = s.getStructured();
        boolean _notEquals_4 = (!Objects.equal(_structured, null));
        if (_notEquals_4) {
          {
            compound_statement _compound = s.getStructured().getCompound();
            boolean _notEquals_5 = (!Objects.equal(_compound, null));
            if (_notEquals_5) {
              _builder.append("; Block");
              _builder.newLine();
              CharSequence _compileSequence = this.compileSequence(e, b, s.getStructured().getCompound().getSequence());
              _builder.append(_compileSequence);
              _builder.newLineIfNotEmpty();
            } else {
              repetitive_statement _repetitive = s.getStructured().getRepetitive();
              boolean _notEquals_6 = (!Objects.equal(_repetitive, null));
              if (_notEquals_6) {
                _builder.newLine();
              } else {
                conditional_statement _conditional = s.getStructured().getConditional();
                boolean _notEquals_7 = (!Objects.equal(_conditional, null));
                if (_notEquals_7) {
                  {
                    if_statement _ifStmt = s.getStructured().getConditional().getIfStmt();
                    boolean _notEquals_8 = (!Objects.equal(_ifStmt, null));
                    if (_notEquals_8) {
                      _builder.append("; If statement");
                      _builder.newLine();
                      if_statement ifStmt = s.getStructured().getConditional().getIfStmt();
                      _builder.newLineIfNotEmpty();
                      CharSequence _computeExpression_1 = this.computeExpression(e, b, ifStmt.getExpression());
                      _builder.append(_computeExpression_1);
                      _builder.newLineIfNotEmpty();
                      _builder.append("and eax, 1 ; Setting zero flag");
                      _builder.newLine();
                      int label = this.conditionalLabelCount++;
                      _builder.newLineIfNotEmpty();
                      _builder.append("jz .else_body");
                      _builder.append(label);
                      _builder.newLineIfNotEmpty();
                      _builder.append(".if_body");
                      _builder.append(label);
                      _builder.append(":");
                      _builder.newLineIfNotEmpty();
                      _builder.append("\t");
                      CharSequence _compileStatement = this.compileStatement(e, b, ifStmt.getIfStatement());
                      _builder.append(_compileStatement, "\t");
                      _builder.newLineIfNotEmpty();
                      _builder.append("\t");
                      _builder.append("jmp .conditional_out");
                      _builder.append(label, "\t");
                      _builder.newLineIfNotEmpty();
                      _builder.append(".else_body");
                      _builder.append(label);
                      _builder.append(":");
                      _builder.newLineIfNotEmpty();
                      {
                        statement _elseStatement = ifStmt.getElseStatement();
                        boolean _notEquals_9 = (!Objects.equal(_elseStatement, null));
                        if (_notEquals_9) {
                          _builder.append("\t");
                          CharSequence _compileStatement_1 = this.compileStatement(e, b, ifStmt.getElseStatement());
                          _builder.append(_compileStatement_1, "\t");
                          _builder.newLineIfNotEmpty();
                        }
                      }
                      _builder.append(".conditional_out");
                      _builder.append(label);
                      _builder.append(":");
                      _builder.newLineIfNotEmpty();
                    } else {
                      case_statement _caseStmt = s.getStructured().getConditional().getCaseStmt();
                      boolean _notEquals_10 = (!Objects.equal(_caseStmt, null));
                      if (_notEquals_10) {
                        _builder.append("; Case statement");
                        _builder.newLine();
                        case_statement caseStmt = s.getStructured().getConditional().getCaseStmt();
                        _builder.newLineIfNotEmpty();
                        int globalLabel = this.caseGlobalLabelCount++;
                        _builder.newLineIfNotEmpty();
                        CharSequence _computeExpression_2 = this.computeExpression(e, b, caseStmt.getExpression());
                        _builder.append(_computeExpression_2);
                        _builder.newLineIfNotEmpty();
                        {
                          EList<case_limb> _cases = caseStmt.getCases();
                          for(final case_limb c : _cases) {
                            _builder.append("; Case limb");
                            _builder.newLine();
                            int label_1 = this.caseLabelCount++;
                            _builder.newLineIfNotEmpty();
                            {
                              EList<constant> _constants = c.getCases().getConstants();
                              for(final constant constant : _constants) {
                                _builder.append("; Comparison with constant");
                                _builder.newLine();
                                _builder.append("mov ecx, ");
                                Object _value = this.getValue(e, b, constant);
                                _builder.append(_value);
                                _builder.newLineIfNotEmpty();
                                _builder.append("cmp eax, ecx");
                                _builder.newLine();
                                _builder.append("je .case_limb_body");
                                _builder.append(label_1);
                                _builder.newLineIfNotEmpty();
                              }
                            }
                            _builder.append("jmp .case_limb_out");
                            _builder.append(label_1);
                            _builder.newLineIfNotEmpty();
                            _builder.append(".case_limb_body");
                            _builder.append(label_1);
                            _builder.append(":");
                            _builder.newLineIfNotEmpty();
                            _builder.append("\t");
                            CharSequence _compileStatement_2 = this.compileStatement(e, b, c.getStatement());
                            _builder.append(_compileStatement_2, "\t");
                            _builder.newLineIfNotEmpty();
                            _builder.append("\t");
                            _builder.append("jmp .case_out");
                            _builder.append(globalLabel, "\t");
                            _builder.newLineIfNotEmpty();
                            _builder.append(".case_limb_out");
                            _builder.append(label_1);
                            _builder.append(":");
                            _builder.newLineIfNotEmpty();
                          }
                        }
                        _builder.append(".case_out");
                        _builder.append(globalLabel);
                        _builder.append(":");
                        _builder.newLineIfNotEmpty();
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    return _builder;
  }
}
